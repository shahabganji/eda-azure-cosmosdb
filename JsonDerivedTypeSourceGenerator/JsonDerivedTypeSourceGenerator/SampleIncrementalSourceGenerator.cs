using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace JsonDerivedTypeSourceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class SampleIncrementalSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Select classes that might be derived from `Event`.
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateForGeneration(s),
                transform: static (ctx, _) => GetClassSymbol(ctx))
            .Where(static symbol => symbol is not null);

        // Combine all derived types into a single list
        var derivedTypes = classDeclarations.Collect();

        // Generate the source code
        context.RegisterSourceOutput(derivedTypes, GenerateSource!);
    }

    private static bool IsCandidateForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
        {
            var x = classDeclarationSyntax.BaseList?.Types.Any(t => t.GetText().ToString() == "Event\n") ?? false;
            return x; // classDeclarationSyntax.BaseList!.Types.Count > 0;
        }

        return false;
    }

    private static INamedTypeSymbol? GetClassSymbol(GeneratorSyntaxContext context)
    {
        // Get the symbol for the class declaration
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol is null)
            return null;

        // Check if it inherits from `Event`
        var baseType = classSymbol.BaseType;

        if (baseType!.ToDisplayString() == "IAmStreamEvent")
            return null;

        return baseType.ToDisplayString() == "EventSourcingCosmosDB.Events.Event" ? classSymbol : null;
    }

    private static void GenerateSource(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> derivedTypes)
    {
        var baseType = derivedTypes.First().BaseType;
        if (baseType == null)
        {
            return;
        }

        var namespaceName = baseType.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("[JsonPolymorphic(IgnoreUnrecognizedTypeDiscriminators = true)]");

        foreach (var derivedType in derivedTypes.Distinct(SymbolEqualityComparer.Default))
        {
            sb.AppendLine($"[JsonDerivedType(typeof({derivedType!.Name}), nameof({derivedType.Name}))]");
        }

        sb.Append($"public abstract partial class {baseType.Name}");
        sb.Append(" {");
        sb.Append(" }");
        sb.AppendLine();

        context.AddSource("EventJsonAttributes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
